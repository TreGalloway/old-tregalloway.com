import * as tracing_1 from "@effect-ts/core/Tracing";
const fileName_1 = "packages/@contentlayer/cli/src/commands/PostInstallCommand.ts";
import * as core from '@contentlayer/core';
import { OT, pipe, T } from '@contentlayer/utils/effect';
import { fs } from '@contentlayer/utils/node';
import * as path from 'node:path';
import { BaseCommand } from './_BaseCommand.js';
export class PostInstallCommand extends BaseCommand {
    constructor() {
        super(...arguments);
        this.executeSafe = () => {
            const { configPath } = this;
            return (OT.withSpan('@contentlayer/cli/commands/PostInstallCommand:executeSafe', { attributes: { cwd: process.cwd() } })(T.gen(function* ($) {
                const artifactsDirPath = yield* $(core.ArtifactsDir.mkdir, fileName_1 + ":15:42");
                yield* $(generateTypes({ artifactsDirPath, moduleName: 'generated', configPath }), fileName_1 + ":17:17");
                yield* $(addToplevelDotpkgToGitignore(), fileName_1 + ":19:17");
            }, fileName_1 + ":14:12")));
        };
    }
}
PostInstallCommand.paths = [['postinstall']];
// TODO unify this implementation with `generateDotpkg`
const generateTypes = ({ artifactsDirPath, moduleName, configPath, }) => T.gen(function* ($) {
    const dirPath = path.join(artifactsDirPath, moduleName);
    const dirExists = yield* $(fs.fileOrDirExists(dirPath), fileName_1 + ":38:31");
    if (!dirExists) {
        yield* $(fs.mkdirp(dirPath), fileName_1 + ":40:15");
    }
    const indexDtsFilePath = path.join(dirPath, 'index.d.ts');
    const indexDtsFileExists = yield* $(fs.fileOrDirExists(indexDtsFilePath), fileName_1 + ":44:40");
    const typesDtsFilePath = path.join(dirPath, 'types.d.ts');
    const typesDtsFileExists = yield* $(fs.fileOrDirExists(typesDtsFilePath), fileName_1 + ":47:40");
    if (indexDtsFileExists && typesDtsFileExists)
        return;
    const sourceEither = yield* $((T.either(core.getConfig({ configPath }), fileName_1 + ":51:80")), fileName_1 + ":51:34");
    if (sourceEither._tag === 'Left') {
        if (sourceEither.left._tag === 'NoConfigFoundError') {
            yield* $(fs.writeFile(indexDtsFilePath, moduleStubFileIndexDts), fileName_1 + ":54:17");
            return;
        }
        else {
            return yield* $(T.fail(sourceEither.left, fileName_1 + ":57:31"), fileName_1 + ":57:24");
        }
    }
    const { source, esbuildHash } = sourceEither.right;
    const schemaDef = yield* $(source.provideSchema(esbuildHash), fileName_1 + ":62:31");
    if (!indexDtsFileExists) {
        yield* $(fs.writeFile(indexDtsFilePath, core.makeDataTypes({ schemaDef })), fileName_1 + ":65:15");
    }
    if (!typesDtsFileExists) {
        const generationOptions = { sourcePluginType: source.type, options: source.options };
        yield* $(fs.writeFile(typesDtsFilePath, core.renderTypes({ schemaDef, generationOptions })), fileName_1 + ":70:15");
    }
}, fileName_1 + ":36:8");
const moduleStubFileIndexDts = `\
// This file is automatically generated by the Contentlayer.
// This is a placeholder until \`contentlayer build\` has been run.

export {}
`;
const addToplevelDotpkgToGitignore = () => T.gen(function* ($) {
    const cwd = yield* $(core.getCwd, fileName_1 + ":83:25");
    const gitignoreFilePath = path.join(cwd, '.gitignore');
    const gitignoreExists = yield* $(fs.fileOrDirExists(gitignoreFilePath), fileName_1 + ":85:37");
    if (gitignoreExists) {
        const gitignoreContent = yield* $(fs.readFile(gitignoreFilePath), fileName_1 + ":87:40");
        if (!gitignoreContent.includes('.contentlayer')) {
            const newGitignoreContent = `\
${gitignoreContent}

# Contentlayer
.contentlayer
`;
            yield* $(fs.writeFile(gitignoreFilePath, newGitignoreContent), fileName_1 + ":97:17");
        }
    }
}, fileName_1 + ":82:8");
//# sourceMappingURL=PostInstallCommand.js.map