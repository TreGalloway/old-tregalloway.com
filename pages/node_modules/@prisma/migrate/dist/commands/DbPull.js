var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  DbPull: () => DbPull
});
var import_sdk = __toModule(require("@prisma/sdk"));
var import_chalk = __toModule(require("chalk"));
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var import_ts_pattern = __toModule(require("ts-pattern"));
var import_errors = __toModule(require("../utils/errors"));
var import_printDatasource = __toModule(require("../utils/printDatasource"));
var import_printDatasources = __toModule(require("../utils/printDatasources"));
var import_removeDatasource = __toModule(require("../utils/removeDatasource"));
var __defProp2 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
const _DbPull = /* @__PURE__ */ __name(class {
  static new() {
    return new _DbPull();
  }
  urlToDatasource(url, defaultProvider) {
    const provider = defaultProvider || (0, import_sdk.protocolToConnectorType)(`${url.split(":")[0]}:`);
    return (0, import_printDatasources.printDatasources)([
      {
        config: {},
        provider,
        name: "db",
        url
      }
    ]);
  }
  async parse(argv) {
    const args = (0, import_sdk.arg)(argv, {
      "--help": Boolean,
      "-h": "--help",
      "--url": String,
      "--print": Boolean,
      "--schema": String,
      "--force": Boolean,
      "--composite-type-depth": Number,
      "--experimental-reintrospection": Boolean,
      "--clean": Boolean
    });
    const spinnerFactory = (0, import_sdk.createSpinner)(!args["--print"]);
    if (args instanceof Error) {
      return this.help(args.message);
    }
    if (args["--help"]) {
      return this.help();
    }
    if (args["--clean"] || args["--experimental-reintrospection"]) {
      const renamedMessages = [];
      if (args["--experimental-reintrospection"]) {
        renamedMessages.push(`The ${import_chalk.default.redBright("--experimental-reintrospection")} flag has been removed and is now the default behavior of ${import_chalk.default.greenBright("prisma db pull")}.`);
      }
      if (args["--clean"]) {
        renamedMessages.push(`The ${import_chalk.default.redBright("--clean")} flag has been renamed to ${import_chalk.default.greenBright("--force")}.`);
      }
      console.error(`
${renamedMessages.join("\n")}
`);
      process.exit(1);
    }
    const url = args["--url"];
    let schemaPath = await (0, import_sdk.getSchemaPath)(args["--schema"]);
    if (schemaPath && !args["--print"]) {
      console.info(import_chalk.default.dim(`Prisma schema loaded from ${import_path.default.relative(process.cwd(), schemaPath)}`));
      (0, import_sdk.loadEnvFile)(args["--schema"], true);
      await (0, import_printDatasource.printDatasource)(schemaPath);
    } else {
      (0, import_sdk.loadEnvFile)(args["--schema"], false);
    }
    if (!url && !schemaPath) {
      throw new import_errors.NoSchemaFoundError();
    }
    const schema = await (0, import_ts_pattern.match)({ url, schemaPath }).when((input) => input.schemaPath !== null, async (input) => {
      var _a;
      const rawSchema = import_fs.default.readFileSync(input.schemaPath, "utf-8");
      if (input.url) {
        const config = await (0, import_sdk.getConfig)({
          datamodel: rawSchema,
          ignoreEnvVarErrors: true
        });
        const provider = (_a = config.datasources[0]) == null ? void 0 : _a.provider;
        const schema2 = `${this.urlToDatasource(input.url, provider)}${(0, import_removeDatasource.removeDatasource)(rawSchema)}`;
        return schema2;
      }
      return rawSchema;
    }).when((input) => input.url !== void 0, (input) => {
      const schema2 = this.urlToDatasource(input.url);
      return Promise.resolve(schema2);
    }).run();
    if (schemaPath) {
      const schema2 = await (0, import_sdk.getSchema)(args["--schema"]);
      const config = await (0, import_sdk.getConfig)({
        datamodel: schema2,
        ignoreEnvVarErrors: true
      });
      const modelRegex = /\s*model\s*(\w+)\s*{/;
      const modelMatch = modelRegex.exec(schema2);
      const isReintrospection = modelMatch;
      if (isReintrospection && !args["--force"] && config.datasources[0].provider === "mongodb") {
        throw new Error(`Iterating on one schema using re-introspection with db pull is currently not supported with MongoDB provider.
You can explicitely ignore and override your current local schema file with ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma db pull --force"))}
Some information will be lost (relations, comments, mapped fields, @ignore...), follow ${(0, import_sdk.link)("https://github.com/prisma/prisma/issues/9585")} for more info.`);
      }
    }
    const engine = new import_sdk.IntrospectionEngine({
      cwd: schemaPath ? import_path.default.dirname(schemaPath) : void 0
    });
    const basedOn = !args["--url"] && schemaPath ? ` based on datasource defined in ${import_chalk.default.underline(import_path.default.relative(process.cwd(), schemaPath))}` : "";
    const introspectionSpinner = spinnerFactory(`Introspecting${basedOn}`);
    const before = Date.now();
    let introspectionSchema = "";
    let introspectionWarnings;
    let introspectionSchemaVersion;
    try {
      const introspectionResult = await engine.introspect(schema, args["--force"], args["--composite-type-depth"]);
      introspectionSchema = introspectionResult.datamodel;
      introspectionWarnings = introspectionResult.warnings;
      introspectionSchemaVersion = introspectionResult.version;
    } catch (e) {
      introspectionSpinner.failure();
      if (e.code === "P4001") {
        if (introspectionSchema.trim() === "") {
          throw new Error(`
${import_chalk.default.red.bold("P4001 ")}${import_chalk.default.red("The introspected database was empty:")} ${url ? import_chalk.default.underline(url) : ""}

${import_chalk.default.bold("prisma db pull")} could not create any models in your ${import_chalk.default.bold("schema.prisma")} file and you will not be able to generate Prisma Client with the ${import_chalk.default.bold((0, import_sdk.getCommandWithExecutor)("prisma generate"))} command.

${import_chalk.default.bold("To fix this, you have two options:")}

- manually create a table in your database.
- make sure the database connection URL inside the ${import_chalk.default.bold("datasource")} block in ${import_chalk.default.bold("schema.prisma")} points to a database that is not empty (it must contain at least one table).

Then you can run ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma db pull"))} again. 
`);
        }
      } else if (e.code === "P1012") {
        console.info();
        throw new Error(`${import_chalk.default.red(`${e.code}`)} Introspection failed as your current Prisma schema file is invalid

Please fix your current schema manually, use ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma validate"))} to confirm it is valid and then run this command again.
Or run this command with the ${import_chalk.default.green("--force")} flag to ignore your current schema and overwrite it. All local modifications will be lost.
`);
      }
      console.info();
      throw e;
    }
    const introspectionWarningsMessage = this.getWarningMessage(introspectionWarnings) || "";
    const prisma1UpgradeMessage = introspectionSchemaVersion.includes("Prisma1") ? `
${import_chalk.default.bold("Upgrading from Prisma 1 to Prisma 2+?")}
      
The database you introspected could belong to a Prisma 1 project.

Please run the following command to upgrade to Prisma 2+:
${import_chalk.default.green("npx prisma-upgrade [path-to-prisma-yml] [path-to-schema-prisma]")}

Note: \`prisma.yml\` and \`schema.prisma\` paths are optional.
 
Learn more about the upgrade process in the docs:
${(0, import_sdk.link)("https://pris.ly/d/upgrading-to-prisma2")}
` : "";
    if (args["--print"]) {
      console.log(introspectionSchema);
      introspectionSchemaVersion && console.log(`
// introspectionSchemaVersion: ${introspectionSchemaVersion}`, prisma1UpgradeMessage.replace(/(\n)/gm, "\n// "));
      if (introspectionWarningsMessage.trim().length > 0) {
        console.error(introspectionWarningsMessage.replace(/(\n)/gm, "\n// "));
      }
    } else {
      schemaPath = schemaPath || "schema.prisma";
      import_fs.default.writeFileSync(schemaPath, introspectionSchema);
      const modelsCount = (introspectionSchema.match(/^model\s+/gm) || []).length;
      const modelsCountMessage = `${modelsCount} ${modelsCount > 1 ? "models" : "model"}`;
      const typesCount = (introspectionSchema.match(/^type\s+/gm) || []).length;
      const typesCountMessage = `${typesCount} ${typesCount > 1 ? "embedded documents" : "embedded document"}`;
      let modelsAndTypesMessage;
      if (typesCount > 0) {
        modelsAndTypesMessage = `${modelsCountMessage} and ${typesCountMessage}`;
      } else {
        modelsAndTypesMessage = `${modelsCountMessage}`;
      }
      const modelsAndTypesCountMessage = modelsCount + typesCount > 1 ? `${modelsAndTypesMessage} and wrote them` : `${modelsAndTypesMessage} and wrote it`;
      const prisma1UpgradeMessageBox = prisma1UpgradeMessage ? "\n\n" + (0, import_sdk.drawBox)({
        height: 16,
        width: 74,
        str: prisma1UpgradeMessage + "\nOnce you upgraded your database schema to Prisma 2+, \ncontinue with the instructions below.\n",
        horizontalPadding: 2
      }) : "";
      introspectionSpinner.success(`Introspected ${modelsAndTypesCountMessage} into ${import_chalk.default.underline(import_path.default.relative(process.cwd(), schemaPath))} in ${import_chalk.default.bold((0, import_sdk.formatms)(Date.now() - before))}${prisma1UpgradeMessageBox}
      ${import_chalk.default.keyword("orange")(introspectionWarningsMessage)}
${`Run ${import_chalk.default.green((0, import_sdk.getCommandWithExecutor)("prisma generate"))} to generate Prisma Client.`}`);
    }
    engine.stop();
    return "";
  }
  getWarningMessage(warnings) {
    if (warnings.length > 0) {
      let message = `
*** WARNING ***
`;
      for (const warning of warnings) {
        message += `
${warning.message}
`;
        if (warning.code === 0) {
        } else if (warning.code === 1) {
          message += warning.affected.map((it) => `- "${it.model}"`).join("\n");
        } else if (warning.code === 2) {
          const modelsGrouped = warning.affected.reduce((acc, it) => {
            if (!acc[it.model]) {
              acc[it.model] = [];
            }
            acc[it.model].push(it.field);
            return acc;
          }, {});
          message += Object.entries(modelsGrouped).map(([model, fields]) => `- Model: "${model}"
  Field(s): "${fields.join('", "')}"`).join("\n");
        } else if (warning.code === 3) {
          message += warning.affected.map((it) => `- Model "${it.model}", field: "${it.field}", original data type: "${it.tpe}"`).join("\n");
        } else if (warning.code === 4) {
          message += warning.affected.map((it) => `- Enum "${it.enm}", value: "${it.value}"`).join("\n");
        } else if (warning.code === 5 || warning.code === 6 || warning.code === 8 || warning.code === 11 || warning.code === 12 || warning.code === 13 || warning.code === 16) {
          message += warning.affected.map((it) => `- Model "${it.model}", field: "${it.field}"`).join("\n");
        } else if (warning.code === 7 || warning.code === 14 || warning.code === 15 || warning.code === 18 || warning.code === 19) {
          message += warning.affected.map((it) => `- Model "${it.model}"`).join("\n");
        } else if (warning.code === 9 || warning.code === 10) {
          message += warning.affected.map((it) => `- Enum "${it.enm}"`).join("\n");
        } else if (warning.code === 17) {
          message += warning.affected.map((it) => `- Model "${it.model}", Index db name: "${it.index_db_name}"`).join("\n");
        } else if (warning.code === 101) {
          message += warning.affected.map((it) => {
            if (it.model) {
              return `- Model "${it.model}", field: "${it.field}", chosen data type: "${it.tpe}"`;
            } else if (it.compositeType) {
              return `- Type "${it.compositeType}", field: "${it.field}", chosen data type: "${it.tpe}"`;
            } else {
              return `Code ${warning.code} - Properties model or compositeType don't exist in ${JSON.stringify(warning.affected, null, 2)}`;
            }
          }).join("\n");
        } else if (warning.code === 102 || warning.code === 103 || warning.code === 104) {
          message += warning.affected.map((it) => {
            if (it.model) {
              return `- Model "${it.model}", field: "${it.field}"`;
            } else if (it.compositeType) {
              return `- Type "${it.compositeType}", field: "${it.field}"`;
            } else {
              return `Code ${warning.code} - Properties model or compositeType don't exist in ${JSON.stringify(warning.affected, null, 2)}`;
            }
          }).join("\n");
        } else if (warning.affected) {
          message += `Code ${warning.code}
${JSON.stringify(warning.affected, null, 2)}`;
        }
        message += `
`;
      }
      return message;
    }
    return void 0;
  }
  help(error) {
    if (error) {
      return new import_sdk.HelpError(`
${import_chalk.default.bold.red(`!`)} ${error}
${_DbPull.help}`);
    }
    return _DbPull.help;
  }
}, "_DbPull");
let DbPull = _DbPull;
__name2(DbPull, "DbPull");
DbPull.help = (0, import_sdk.format)(`
Pull the state from the database to the Prisma schema using introspection

${import_chalk.default.bold("Usage")}

  ${import_chalk.default.dim("$")} prisma db pull [flags/options]

${import_chalk.default.bold("Flags")}

              -h, --help   Display this help message
                 --force   Ignore current Prisma schema file
                 --print   Print the introspected Prisma schema to stdout

${import_chalk.default.bold("Options")}

                --schema   Custom path to your Prisma schema
  --composite-type-depth   Specify the depth for introspecting composite types (e.g. Embedded Documents in MongoDB)
                           Number, default is -1 for infinite depth, 0 = off

${import_chalk.default.bold("Examples")}

With an existing Prisma schema
  ${import_chalk.default.dim("$")} prisma db pull

Or specify a Prisma schema path
  ${import_chalk.default.dim("$")} prisma db pull --schema=./schema.prisma

Instead of saving the result to the filesystem, you can also print it to stdout
  ${import_chalk.default.dim("$")} prisma db pull --print

Overwrite the current schema with the introspected schema instead of enriching it
  ${import_chalk.default.dim("$")} prisma db pull --force

Set composite types introspection depth to 2 levels
  ${import_chalk.default.dim("$")} prisma db pull --composite-type-depth=2

`);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DbPull
});
