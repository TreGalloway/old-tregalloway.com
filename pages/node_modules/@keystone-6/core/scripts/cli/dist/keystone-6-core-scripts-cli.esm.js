import meow from 'meow';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import path__default from 'path';
import url from 'url';
import util from 'util';
import { createServer } from 'http';
import express from 'express';
import { printSchema } from 'graphql';
import * as fs from 'fs-extra';
import fs__default from 'fs-extra';
import chalk from 'chalk';
import { i as initConfig, s as serializePathForImport, c as createSystem, g as generateAdminUI, w as writeAdminFile } from '../../../dist/initConfig-5d2c2305.esm.js';
import { d as devMigrations, p as pushPrismaSchemaToDatabase } from '../../../dist/migrations-26e4c0d0.esm.js';
import { r as requireSource } from '../../../dist/requireSource-1c1d6d02.esm.js';
import { d as defaults, c as createExpressServer, a as createAdminUIMiddleware } from '../../../dist/createAdminUIMiddleware-44525135.esm.js';
import { p as printPrismaSchema, b as getSchemaPaths, c as getFormattedGraphQLSchema, d as generateNodeModulesArtifactsWithoutPrismaClient, e as generateCommittedArtifacts, a as generateNodeModulesArtifacts, r as requirePrismaClient, v as validateCommittedArtifacts } from '../../../dist/artifacts-de4fd409.esm.js';
import { g as getConfigPath, a as getAdminPath, E as ExitError } from '../../../dist/utils-b64dcc3e.esm.js';
import { createSessionContext } from '../../../session/dist/keystone-6-core-session.esm.js';
import { q as initialiseLists } from '../../../dist/types-for-lists-9414dddb.esm.js';
import execa from 'execa';
import 'p-limit';
import '../../../dist/core-c6bc4160.esm.js';
import '../../../dist/mysql-673b47d5.esm.js';
import '../../../dist/graphql-ts-schema-57db0426.esm.js';
import '@graphql-ts/schema';
import 'graphql-type-json';
import 'graphql-upload/GraphQLUpload.js';
import 'decimal.js';
import '@graphql-ts/schema/api-without-context';
import '@graphql-ts/extend';
import '@graphql-ts/schema/api-with-context';
import '@graphql-tools/schema';
import '../../../dist/graphql-errors-68845105.esm.js';
import 'apollo-server-errors';
import 'resolve';
import '@nodelib/fs.walk';
import '@emotion/hash';
import '../../../dist/admin-meta-graphql-9585711c.esm.js';
import '@apollo/client';
import '@babel/runtime/helpers/classPrivateFieldInitSpec';
import '@babel/runtime/helpers/classPrivateFieldGet';
import '@babel/runtime/helpers/classPrivateFieldSet';
import '@babel/runtime/helpers/defineProperty';
import 'uuid';
import 'image-type';
import 'image-size';
import 'stream';
import '@aws-sdk/s3-request-presigner';
import '@aws-sdk/client-s3';
import '@aws-sdk/lib-storage';
import 'crypto';
import 'filenamify';
import '@sindresorhus/slugify';
import 'cuid';
import '../../../dist/package-path-5ec371a3.esm.js';
import '@prisma/sdk';
import '@prisma/migrate';
import 'pirates';
import '@babel/core';
import 'source-map-support';
import 'cors';
import 'graphql-upload/graphqlUploadExpress.js';
import '../../../dist/createApolloServer-23a6674d.esm.js';
import 'apollo-server-micro';
import 'apollo-server-express';
import 'apollo-server-core';
import 'module';
import 'prettier';
import 'prompts';
import 'cookie';
import '@hapi/iron';
import 'uid-safe';
import 'graphql/execution/values';
import 'pluralize';

async function buildAdminUI(projectAdminPath) {
  let prevNodeEnv = process.env.NODE_ENV; // Next does a broken build unless we set NODE_ENV to production
  // @ts-ignore

  process.env.NODE_ENV = 'production';

  try {
    // importing next/dist/build is quite expensive so we're requiring it lazily

    /** We do this to stop webpack from bundling next inside of next */
    const next = 'next/dist/build';

    const build = require(next).default;

    await build(projectAdminPath);
  } finally {
    if (prevNodeEnv === undefined) {
      // @ts-ignore
      delete process.env.NODE_ENV;
    } else {
      // @ts-ignore
      process.env.NODE_ENV = prevNodeEnv;
    }
  }
}

const _excluded = ["server"],
      _excluded2 = ["extendHttpServer"],
      _excluded3 = ["adminMeta", "graphQLSchema", "createContext", "prismaSchema", "apolloServer"];
const devLoadingHTMLFilepath = path__default.join(path__default.dirname(require.resolve('@keystone-6/core/package.json')), 'static', 'dev-loading.html');

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

const cleanConfig = config => {
  const {
    server
  } = config,
        rest = _objectWithoutProperties(config, _excluded);

  if (server) {
    const restServer = _objectWithoutProperties(server, _excluded2);

    return _objectSpread(_objectSpread({}, rest), {}, {
      server: restServer
    });
  }

  return rest;
};

const dev = async (cwd, shouldDropDatabase) => {
  var _config$server;

  console.log('‚ú® Starting Keystone');
  const app = express();
  let expressServer = null;
  const httpServer = createServer(app);
  let hasAddedAdminUIMiddleware = false;
  let disconnect = null; // note that because we don't catch this throwing, if this fails it'll crash the process
  // so that means if
  // - you have an error in your config on startup -> will fail to start and you have to start the process manually after fixing the problem
  // - you have an error in your config after startup -> will keep the last working version until importing the config succeeds
  // also, if you're thinking "why not always use the Next api route to get the config"?
  // this will get the GraphQL API up earlier

  const configWithHTTP = initConfig(requireSource(getConfigPath(cwd)).default);
  const config = cleanConfig(configWithHTTP);

  const isReady = () => {
    var _config$ui;

    return expressServer !== null && (hasAddedAdminUIMiddleware || ((_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.isDisabled) === true);
  };

  const initKeystone = async () => {
    var _configWithHTTP$serve, _config$ui2;

    await fs__default.remove(getAdminPath(cwd));
    const p = serializePathForImport(path__default.relative(path__default.join(getAdminPath(cwd), 'pages', 'api'), `${cwd}/keystone`));

    const _await$setupInitialKe = await setupInitialKeystone(config, cwd, shouldDropDatabase),
          {
      adminMeta,
      graphQLSchema,
      createContext,
      prismaSchema,
      apolloServer
    } = _await$setupInitialKe,
          rest = _objectWithoutProperties(_await$setupInitialKe, _excluded3);

    if (configWithHTTP !== null && configWithHTTP !== void 0 && (_configWithHTTP$serve = configWithHTTP.server) !== null && _configWithHTTP$serve !== void 0 && _configWithHTTP$serve.extendHttpServer) {
      const createRequestContext = async (req, res) => createContext({
        sessionContext: config.session ? await createSessionContext(config.session, req, res, createContext) : undefined,
        req
      });

      configWithHTTP.server.extendHttpServer(httpServer, createRequestContext, graphQLSchema);
    }

    const prismaClient = createContext().prisma;
    ({
      disconnect,
      expressServer
    } = rest); // if you've disabled the Admin UI, sorry, no live reloading
    // the chance that someone is actually using this is probably quite low
    // and starting Next in tests where we don't care about it would slow things down quite a bit

    if ((_config$ui2 = config.ui) !== null && _config$ui2 !== void 0 && _config$ui2.isDisabled) {
      initKeystonePromiseResolve();
      return;
    }

    const adminUIMiddleware = await initAdminUI(config, graphQLSchema, adminMeta, cwd, createContext);
    expressServer.use(adminUIMiddleware);
    hasAddedAdminUIMiddleware = true;
    initKeystonePromiseResolve(); // this exports a function which dynamically requires the config rather than directly importing it.
    // this allows us to control exactly _when_ the gets evaluated so that we can handle errors ourselves.
    // note this is intentionally using CommonJS and not ESM because by doing a dynamic import, webpack
    // will generate a separate chunk for that whereas a require will be in the same bundle but the execution can still be delayed.
    // dynamic importing didn't work on windows because it couldn't get the path to require the chunk for some reason

    await fs__default.outputFile(`${getAdminPath(cwd)}/pages/api/__keystone_api_build.js`, `exports.getConfig = () => require(${p});
const x = Math.random();
exports.default = function (req, res) { return res.send(x.toString()) }
`);
    let lastVersion = '';
    let lastError = undefined;
    const originalPrismaSchema = printPrismaSchema(initialiseLists(config), config.db.provider, config.db.prismaPreviewFeatures, config.db.additionalPrismaDatasourceProperties);
    let lastPrintedGraphQLSchema = printSchema(graphQLSchema);
    let lastApolloServer = apolloServer;

    while (true) {
      await wait(500);

      try {
        // this fetching essentially does two things:
        // - keeps the api route built, if we don't fetch it, Next will stop compiling it
        // - returns a random number which when it changes indicates that the config _might_ have changed
        //   note that it can go off randomly so the version changing doesn't necessarily
        //   mean that the config has changed, Next might have just reloaded for some random reason
        //   so we shouldn't log something like "hey, we reloaded your config"
        //   because it would go off at times when the user didn't change their config
        const version = await fetch(`http://localhost:${httpOptions.port}/api/__keystone_api_build`).then(x => x.text());

        if (lastVersion !== version) {
          lastVersion = version;

          const resolved = require.resolve(`${getAdminPath(cwd)}/.next/server/pages/api/__keystone_api_build`);

          delete require.cache[resolved]; // webpack will make modules that import Node ESM externals(which must be loaded with dynamic import)
          // export a promise that resolves to the actual export so yeah, we need to await a require call
          // technically, the await for requiring the api route module isn't necessary since there are no imports there
          // but just in case webpack decides to make it async in the future, this'll still work

          const apiRouteModule = await require(resolved);
          const uninitializedConfig = (await apiRouteModule.getConfig()).default;
          const newConfigWithHttp = initConfig(uninitializedConfig);
          const newConfig = cleanConfig(newConfigWithHttp);
          const newPrismaSchema = printPrismaSchema(initialiseLists(newConfig), newConfig.db.provider, newConfig.db.prismaPreviewFeatures, newConfig.db.additionalPrismaDatasourceProperties);

          if (originalPrismaSchema !== newPrismaSchema) {
            console.log('üîÑ Your prisma schema has changed, please restart Keystone');
            process.exit(1);
          } // we only need to test for the things which influence the prisma client creation
          // and aren't written into the prisma schema since we check whether the prisma schema has changed above


          if (newConfig.db.enableLogging !== config.db.enableLogging || newConfig.db.url !== config.db.url || newConfig.db.useMigrations !== config.db.useMigrations) {
            console.log('Your db config has changed, please restart Keystone');
            process.exit(1);
          }

          const {
            graphQLSchema,
            getKeystone,
            adminMeta
          } = createSystem(newConfig, true); // we're not using generateCommittedArtifacts or any of the similar functions
          // because we will never need to write a new prisma schema here
          // and formatting the prisma schema leaves some listeners on the process
          // which means you get a "there's probably a memory leak" warning from node

          const newPrintedGraphQLSchema = printSchema(graphQLSchema);

          if (newPrintedGraphQLSchema !== lastPrintedGraphQLSchema) {
            await fs__default.writeFile(getSchemaPaths(cwd).graphql, getFormattedGraphQLSchema(newPrintedGraphQLSchema));
            lastPrintedGraphQLSchema = newPrintedGraphQLSchema;
          }

          await generateNodeModulesArtifactsWithoutPrismaClient(graphQLSchema, newConfig, cwd);
          await generateAdminUI(newConfig, graphQLSchema, adminMeta, getAdminPath(cwd), true);
          const keystone = getKeystone(function fakePrismaClientClass() {
            return prismaClient;
          });
          await keystone.connect();
          const servers = await createExpressServer(newConfig, graphQLSchema, keystone.createContext);
          servers.expressServer.use(adminUIMiddleware);
          expressServer = servers.expressServer;
          let prevApolloServer = lastApolloServer;
          lastApolloServer = servers.apolloServer;
          await prevApolloServer.stop();
          lastError = undefined;
        }
      } catch (err) {
        // since Next will sometimes randomly refresh the api route even though it hasn't changed
        // we want to avoid showing the same error again
        const printed = util.inspect(err);

        if (printed !== lastError) {
          console.log('üö®', chalk.red('There was an error loading your Keystone config'));
          console.log(printed);
          lastError = printed;
        }
      }
    }
  }; // You shouldn't really be doing a healthcheck on the dev server, but we
  // respond on the endpoint with the correct error code just in case. This
  // doesn't send the configured data shape, because config doesn't allow
  // for the "not ready" case but that's probably OK.


  if ((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.healthCheck) {
    const healthCheckPath = config.server.healthCheck === true ? defaults.healthCheckPath : config.server.healthCheck.path || defaults.healthCheckPath;
    app.use(healthCheckPath, (req, res, next) => {
      if (expressServer) return next();
      res.status(503).json({
        status: 'fail',
        timestamp: Date.now()
      });
    });
  } // Serve the dev status page for the Admin UI


  app.use('/__keystone_dev_status', (req, res) => {
    res.json({
      ready: isReady() ? true : false
    });
  }); // Pass the request the express server, or serve the loading page

  app.use((req, res, next) => {
    var _config$ui3, _config$graphql;

    // If both the express server and Admin UI Middleware are ready, we're go!
    if (expressServer && (hasAddedAdminUIMiddleware || ((_config$ui3 = config.ui) === null || _config$ui3 === void 0 ? void 0 : _config$ui3.isDisabled) === true)) {
      return expressServer(req, res, next);
    } // Otherwise, we may be able to serve the GraphQL API


    const {
      pathname
    } = url.parse(req.url);

    if (expressServer && pathname === (((_config$graphql = config.graphql) === null || _config$graphql === void 0 ? void 0 : _config$graphql.path) || '/api/graphql')) {
      return expressServer(req, res, next);
    } // Serve the loading page


    res.sendFile(devLoadingHTMLFilepath);
  });
  let initKeystonePromiseResolve;
  let initKeystonePromiseReject;
  let initKeystonePromise = new Promise((resolve, reject) => {
    initKeystonePromiseResolve = resolve;
    initKeystonePromiseReject = reject;
  });
  const httpOptions = {
    port: 3000
  };

  if (config !== null && config !== void 0 && config.server && 'port' in config.server) {
    httpOptions.port = config.server.port;
  }

  if (config !== null && config !== void 0 && config.server && 'options' in config.server && config.server.options) {
    Object.assign(httpOptions, config.server.options);
  } // preference env.PORT if supplied


  if ('PORT' in process.env) {
    httpOptions.port = parseInt(process.env.PORT || '');
  }

  const server = httpServer.listen(httpOptions, err => {
    var _config$graphql2;

    if (err) throw err; // We start initialising Keystone after the dev server is ready,

    console.log(`‚≠êÔ∏è Dev Server Starting on http://localhost:${httpOptions.port}`);
    console.log(`‚≠êÔ∏è GraphQL API Starting on http://localhost:${httpOptions.port}${((_config$graphql2 = config.graphql) === null || _config$graphql2 === void 0 ? void 0 : _config$graphql2.path) || '/api/graphql'}`); // Don't start initialising Keystone until the dev server is ready,
    // otherwise it slows down the first response significantly

    initKeystone().catch(err => {
      server.close(async closeErr => {
        if (closeErr) {
          console.log('There was an error while closing the server');
          console.log(closeErr);
        }

        try {
          var _disconnect;

          await ((_disconnect = disconnect) === null || _disconnect === void 0 ? void 0 : _disconnect());
        } catch (err) {
          console.log('There was an error while disconnecting from the database');
          console.log(err);
        }

        initKeystonePromiseReject(err);
      });
    });
  });
  await initKeystonePromise;
  return () => new Promise((resolve, reject) => {
    server.close(async err => {
      try {
        var _disconnect2;

        await ((_disconnect2 = disconnect) === null || _disconnect2 === void 0 ? void 0 : _disconnect2());
      } catch (disconnectionError) {
        if (!err) {
          err = disconnectionError;
        } else {
          console.log('There was an error while disconnecting from the database');
          console.log(disconnectionError);
        }
      }

      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
};

async function setupInitialKeystone(config, cwd, shouldDropDatabase) {
  const {
    graphQLSchema,
    adminMeta,
    getKeystone
  } = createSystem(config); // Generate the Artifacts

  console.log('‚ú® Generating GraphQL and Prisma schemas');
  const prismaSchema = (await generateCommittedArtifacts(graphQLSchema, config, cwd)).prisma;
  let keystonePromise = generateNodeModulesArtifacts(graphQLSchema, config, cwd).then(() => {
    const prismaClient = requirePrismaClient(cwd);
    return getKeystone(prismaClient);
  });
  let migrationPromise; // Set up the Database

  if (config.db.useMigrations) {
    migrationPromise = devMigrations(config.db.url, config.db.shadowDatabaseUrl, prismaSchema, getSchemaPaths(cwd).prisma, shouldDropDatabase);
  } else {
    migrationPromise = pushPrismaSchemaToDatabase(config.db.url, config.db.shadowDatabaseUrl, prismaSchema, getSchemaPaths(cwd).prisma, shouldDropDatabase);
  }

  const [keystone] = await Promise.all([keystonePromise, migrationPromise]);
  const {
    createContext
  } = keystone; // Connect to the Database

  console.log('‚ú® Connecting to the database');
  await keystone.connect(); // Set up the Express Server

  console.log('‚ú® Creating server');
  const {
    apolloServer,
    expressServer
  } = await createExpressServer(config, graphQLSchema, createContext);
  console.log(`‚úÖ GraphQL API ready`); // Make local storage folders if used

  for (const val of Object.values(config.storage || {})) {
    if (val.kind !== 'local') continue;
    fs__default.mkdirSync(val.storagePath, {
      recursive: true
    });
    console.warn(`WARNING: 'mkdir -p ${val.storagePath}' won't happen in production`);
  }

  return {
    adminMeta,
    disconnect: () => keystone.disconnect(),
    expressServer,
    apolloServer,
    graphQLSchema,
    createContext,
    prismaSchema
  };
}

async function initAdminUI(config, graphQLSchema, adminMeta, cwd, createContext) {
  console.log('‚ú® Generating Admin UI code');
  await generateAdminUI(config, graphQLSchema, adminMeta, getAdminPath(cwd), false);
  console.log('‚ú® Preparing Admin UI app');
  const middleware = await createAdminUIMiddleware(config, createContext, true, getAdminPath(cwd));
  console.log(`‚úÖ Admin UI ready`);
  return middleware;
}

const start = async cwd => {
  var _config$ui;

  console.log('‚ú® Starting Keystone'); // This is the compiled version of the configuration which was generated during the build step.
  // See reexportKeystoneConfig().

  const apiFile = path__default.join(getAdminPath(cwd), '.next/server/pages/api/__keystone_api_build.js');

  if (!fs.existsSync(apiFile)) {
    console.log('üö® keystone build must be run before running keystone start');
    throw new ExitError(1);
  } // webpack will make modules that import Node ESM externals(which must be loaded with dynamic import)
  // export a promise that resolves to the actual export so yeah, we need to await a require call


  const config = initConfig((await require(apiFile)).config);
  const {
    getKeystone,
    graphQLSchema
  } = createSystem(config);
  const prismaClient = requirePrismaClient(cwd);
  const keystone = getKeystone(prismaClient);
  console.log('‚ú® Connecting to the database');
  await keystone.connect();
  console.log('‚ú® Creating server');
  const {
    expressServer,
    httpServer
  } = await createExpressServer(config, graphQLSchema, keystone.createContext);
  console.log(`‚úÖ GraphQL API ready`);

  if (!((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled)) {
    console.log('‚ú® Preparing Admin UI Next.js app');
    expressServer.use(await createAdminUIMiddleware(config, keystone.createContext, false, getAdminPath(cwd)));
    console.log(`‚úÖ Admin UI ready`);
  }

  const options = {
    port: 3000
  };

  if (config !== null && config !== void 0 && config.server && 'port' in config.server) {
    options.port = config.server.port;
  }

  if (config !== null && config !== void 0 && config.server && 'options' in config.server && config.server.options) {
    Object.assign(options, config.server.options);
  } // preference env.PORT if supplied


  if ('PORT' in process.env) {
    options.port = parseInt(process.env.PORT || '');
  }

  httpServer.listen(options, err => {
    if (err) throw err;
    console.log(`‚≠êÔ∏è Server Ready on http://localhost:${options.port}`);
  });
};

const reexportKeystoneConfig = async (cwd, isDisabled) => {
  const projectAdminPath = getAdminPath(cwd);
  const configPath = getConfigPath(cwd);

  if (isDisabled) {
    // Nuke any existing files in our target directory
    await fs__default.remove(projectAdminPath);
  } // We re-export the Keystone config file into the Admin UI project folder
  // so that when we run the build step, we will end up with a compiled version
  // of the configuration file in the .next/ directory. Even if we're not building
  // an Admin UI, we still need to run the `build()` function so that this config
  // file is correctly compiled.


  const pkgDir = path__default.dirname(require.resolve('@keystone-6/core/package.json'));
  const p = serializePathForImport(path__default.relative(path__default.join(projectAdminPath, 'pages', 'api'), configPath));
  const files = [{
    mode: 'write',
    src: `export { default as config } from ${p};
            export default function (req, res) { return res.status(500) }`,
    outputPath: path__default.join('pages', 'api', '__keystone_api_build.js')
  }];

  if (isDisabled) {
    // These are the basic files required to have a valid Next.js project. If the
    // Admin UI is disabled then we need to do this ourselves here.
    files.push({
      mode: 'copy',
      inputPath: path__default.join(pkgDir, 'static', 'next.config.js'),
      outputPath: 'next.config.js'
    }, {
      mode: 'copy',
      inputPath: path__default.join(pkgDir, 'static', 'tsconfig.json'),
      outputPath: 'tsconfig.json'
    });
  }

  await Promise.all(files.map(file => writeAdminFile(file, projectAdminPath)));
};

async function build(cwd) {
  var _config$ui, _config$ui2;

  const config = initConfig(requireSource(getConfigPath(cwd)).default);
  const {
    graphQLSchema,
    adminMeta
  } = createSystem(config);
  await validateCommittedArtifacts(graphQLSchema, config, cwd);
  console.log('‚ú® Building Keystone'); // FIXME: This needs to generate clients for the correct build target using binaryTarget
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#binarytargets-options

  await generateNodeModulesArtifacts(graphQLSchema, config, cwd);

  if ((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled) {
    console.log('‚ú® Skipping Admin UI code generation');
  } else {
    console.log('‚ú® Generating Admin UI code');
    await generateAdminUI(config, graphQLSchema, adminMeta, getAdminPath(cwd), false);
  }

  console.log('‚ú® Generating Keystone config code');
  await reexportKeystoneConfig(cwd, (_config$ui2 = config.ui) === null || _config$ui2 === void 0 ? void 0 : _config$ui2.isDisabled);
  console.log('‚ú® Building Admin UI');
  await buildAdminUI(getAdminPath(cwd));
}

async function prisma(cwd, args) {
  const config = initConfig(requireSource(getConfigPath(cwd)).default);
  const {
    graphQLSchema
  } = createSystem(config);
  await validateCommittedArtifacts(graphQLSchema, config, cwd);
  await generateNodeModulesArtifacts(graphQLSchema, config, cwd);
  const result = await execa('node', [require.resolve('prisma'), ...args], {
    cwd,
    stdio: 'inherit',
    reject: false,
    env: _objectSpread(_objectSpread({}, process.env), {}, {
      DATABASE_URL: config.db.url,
      PRISMA_HIDE_UPDATE_MESSAGE: '1'
    })
  });

  if (result.exitCode !== 0) {
    throw new ExitError(result.exitCode);
  }
}

// There‚Äôs some files that we need to generate into node_modules and it‚Äôs
// important to have them available immediately so things like TypeScript
// won‚Äôt fail.
// We want to validate that your Prisma and GraphQL schemas are up to date
// to prevent the awkward ‚Äúthis is changing because of a previous PR that
// didn‚Äôt update these things‚Äù.
// Why do validation in the postinstall rather than a separate validate command?
//
// It means that it‚Äôs hard to get it wrong. You have to run the postinstall
// script anyway so it prevents ‚Äúoh no, you forgot add this to your CI‚Äù
// node_modules
//   .prisma/client (this is where Prisma generates the client to by default,
//      this means we can have a conversation about whether we should tell
//      people to use @prisma/client directly for certain things though we
//      are not necessarily saying that‚Äôs what we should do)
//   .keystone
//     - All .js files will have a corresponding .d.ts file for TypeScript.
//       We are generating vanilla JavaScript because:
//         * the user may not be using TypeScript
//         * we can‚Äôt/shouldn‚Äôt rely on files in node_modules being transpiled even if they are
//     - types.{js,.ts}: .d.ts will be the same as current .keystone/schema-types.ts, the .js will be empty
//     - next/graphql-api.js: to be imported into a next app as an api route
//         * only generated with generateNextGraphqlAPI option
//     - api.js:  includes the lists API (full exports to be decided elsewhere
//         * only generated with generateNodeAPI option

async function postinstall(cwd, shouldFix) {
  const config = initConfig(requireSource(getConfigPath(cwd)).default);
  const {
    graphQLSchema
  } = createSystem(config);

  if (shouldFix) {
    await generateCommittedArtifacts(graphQLSchema, config, cwd);
    console.log('‚ú® Generated GraphQL and Prisma schemas');
  } else {
    await validateCommittedArtifacts(graphQLSchema, config, cwd);
    console.log('‚ú® GraphQL and Prisma schemas are up to date');
  }

  await generateNodeModulesArtifacts(graphQLSchema, config, cwd);
}

const commands = {
  dev,
  start,
  build,
  prisma,
  postinstall
};
async function cli(cwd, argv) {
  const {
    input,
    help,
    flags
  } = meow(`
    Usage
      $ keystone [command]
    Commands
        dev           start the project in development mode (default)
        postinstall   generate client APIs and types (optional)
        build         build the project (must be done before using start)
        start         start the project in production mode
        prisma        run Prisma CLI commands safely
    `, {
    flags: {
      fix: {
        default: false,
        type: 'boolean'
      },
      resetDb: {
        default: false,
        type: 'boolean'
      }
    },
    argv
  });
  const command = input[0] || 'dev';

  if (!isCommand(command)) {
    console.log(`${command} is not a command that keystone accepts`);
    console.log(help);
    throw new ExitError(1);
  }

  if (command === 'prisma') {
    return prisma(cwd, argv.slice(1));
  } else if (command === 'postinstall') {
    return postinstall(cwd, flags.fix);
  } else if (command === 'dev') {
    return dev(cwd, flags.resetDb);
  } else {
    return commands[command](cwd);
  }
}

function isCommand(command) {
  return command in commands;
}

export { cli };
