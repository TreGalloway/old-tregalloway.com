import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import * as cookie from 'cookie';
import Iron from '@hapi/iron';
import { sync } from 'uid-safe';

const _excluded = ["store", "maxAge"];

function generateSessionId() {
  return sync(24);
}

const TOKEN_NAME = 'keystonejs-session';
const MAX_AGE = 60 * 60 * 8; // 8 hours
// should we also accept httpOnly?

function statelessSessions(_ref) {
  let {
    secret,
    maxAge = MAX_AGE,
    path = '/',
    secure = process.env.NODE_ENV === 'production',
    ironOptions = Iron.defaults,
    domain,
    sameSite = 'lax'
  } = _ref;

  if (!secret) {
    throw new Error('You must specify a session secret to use sessions');
  }

  if (secret.length < 32) {
    throw new Error('The session secret must be at least 32 characters long');
  }

  return {
    async get(_ref2) {
      var _req$headers$authoriz;

      let {
        req
      } = _ref2;
      const cookies = cookie.parse(req.headers.cookie || '');
      const bearer = (_req$headers$authoriz = req.headers.authorization) === null || _req$headers$authoriz === void 0 ? void 0 : _req$headers$authoriz.replace('Bearer ', '');
      const token = bearer || cookies[TOKEN_NAME];
      if (!token) return;

      try {
        return await Iron.unseal(token, secret, ironOptions);
      } catch (err) {}
    },

    async end(_ref3) {
      let {
        res
      } = _ref3;
      res.setHeader('Set-Cookie', cookie.serialize(TOKEN_NAME, '', {
        maxAge: 0,
        expires: new Date(),
        httpOnly: true,
        secure,
        path,
        sameSite,
        domain
      }));
    },

    async start(_ref4) {
      let {
        res,
        data
      } = _ref4;
      const sealedData = await Iron.seal(data, secret, _objectSpread(_objectSpread({}, ironOptions), {}, {
        ttl: maxAge * 1000
      }));
      res.setHeader('Set-Cookie', cookie.serialize(TOKEN_NAME, sealedData, {
        maxAge,
        expires: new Date(Date.now() + maxAge * 1000),
        httpOnly: true,
        secure,
        path,
        sameSite,
        domain
      }));
      return sealedData;
    }

  };
}
function storedSessions(_ref5) {
  let {
    store: storeOption,
    maxAge = MAX_AGE
  } = _ref5,
      statelessSessionsOptions = _objectWithoutProperties(_ref5, _excluded);

  let {
    get,
    start,
    end
  } = statelessSessions(_objectSpread(_objectSpread({}, statelessSessionsOptions), {}, {
    maxAge
  }));
  let store = typeof storeOption === 'function' ? storeOption({
    maxAge
  }) : storeOption;
  let isConnected = false;
  return {
    async get(_ref6) {
      let {
        req,
        createContext
      } = _ref6;
      const data = await get({
        req,
        createContext
      });
      const sessionId = data === null || data === void 0 ? void 0 : data.sessionId;

      if (typeof sessionId === 'string') {
        if (!isConnected) {
          var _store$connect;

          await ((_store$connect = store.connect) === null || _store$connect === void 0 ? void 0 : _store$connect.call(store));
          isConnected = true;
        }

        return store.get(sessionId);
      }
    },

    async start(_ref7) {
      let {
        res,
        data,
        createContext
      } = _ref7;
      let sessionId = generateSessionId();

      if (!isConnected) {
        var _store$connect2;

        await ((_store$connect2 = store.connect) === null || _store$connect2 === void 0 ? void 0 : _store$connect2.call(store));
        isConnected = true;
      }

      await store.set(sessionId, data);
      return (start === null || start === void 0 ? void 0 : start({
        res,
        data: {
          sessionId
        },
        createContext
      })) || '';
    },

    async end(_ref8) {
      let {
        req,
        res,
        createContext
      } = _ref8;
      const data = await get({
        req,
        createContext
      });
      const sessionId = data === null || data === void 0 ? void 0 : data.sessionId;

      if (typeof sessionId === 'string') {
        if (!isConnected) {
          var _store$connect3;

          await ((_store$connect3 = store.connect) === null || _store$connect3 === void 0 ? void 0 : _store$connect3.call(store));
          isConnected = true;
        }

        await store.delete(sessionId);
      }

      await (end === null || end === void 0 ? void 0 : end({
        req,
        res,
        createContext
      }));
    },

    async disconnect() {
      if (isConnected) {
        var _store$disconnect;

        await ((_store$disconnect = store.disconnect) === null || _store$disconnect === void 0 ? void 0 : _store$disconnect.call(store));
        isConnected = false;
      }
    }

  };
}
/**
 * This is the function createSystem uses to implement the session strategy provided
 */

async function createSessionContext(sessionStrategy, req, res, createContext) {
  return {
    session: await sessionStrategy.get({
      req,
      createContext
    }),
    startSession: data => sessionStrategy.start({
      res,
      data,
      createContext
    }),
    endSession: () => sessionStrategy.end({
      req,
      res,
      createContext
    })
  };
}

export { createSessionContext, statelessSessions, storedSessions };
