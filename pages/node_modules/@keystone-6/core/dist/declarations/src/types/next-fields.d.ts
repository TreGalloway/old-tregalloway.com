import Decimal from 'decimal.js';
import { graphql } from '..';
import { BaseListTypeInfo } from './type-info';
import { CommonFieldConfig } from './config';
import { DatabaseProvider } from './core';
import { AdminMetaRootVal, JSONValue, KeystoneContext, MaybePromise, StorageConfig } from '.';
export { Decimal };
export declare type BaseItem = {
    id: {
        toString(): string;
    };
    [key: string]: unknown;
};
export declare type ListGraphQLTypes = {
    types: GraphQLTypesForList;
};
export declare type FieldData = {
    lists: Record<string, ListGraphQLTypes>;
    provider: DatabaseProvider;
    getStorage: (storage: string) => StorageConfig | undefined;
    listKey: string;
    fieldKey: string;
};
export declare type FieldTypeFunc<ListTypeInfo extends BaseListTypeInfo> = (data: FieldData) => NextFieldType<DBField, graphql.Arg<graphql.InputType> | undefined, graphql.Arg<graphql.InputType>, graphql.Arg<graphql.NullableInputType, false>, graphql.Arg<graphql.NullableInputType, false>, graphql.Arg<graphql.NullableInputType, false>, ListTypeInfo>;
export declare type NextFieldType<TDBField extends DBField = DBField, CreateArg extends graphql.Arg<graphql.InputType> | undefined = graphql.Arg<graphql.InputType> | undefined, UpdateArg extends graphql.Arg<graphql.InputType> = graphql.Arg<graphql.InputType>, UniqueWhereArg extends graphql.Arg<graphql.NullableInputType, false> = graphql.Arg<graphql.NullableInputType, false>, OrderByArg extends graphql.Arg<graphql.NullableInputType, false> = graphql.Arg<graphql.NullableInputType, false>, FilterArg extends graphql.Arg<graphql.NullableInputType, false> = graphql.Arg<graphql.NullableInputType, false>, ListTypeInfo extends BaseListTypeInfo = BaseListTypeInfo> = {
    dbField: TDBField;
} & FieldTypeWithoutDBField<TDBField, CreateArg, UpdateArg, UniqueWhereArg, OrderByArg, FilterArg, ListTypeInfo>;
declare type ScalarPrismaTypes = {
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    DateTime: Date;
    BigInt: bigint;
    Json: JSONValue;
    Decimal: Decimal;
};
declare type NumberLiteralDefault = {
    kind: 'literal';
    value: number;
};
declare type BigIntLiteralDefault = {
    kind: 'literal';
    value: bigint;
};
declare type BooleanLiteralDefault = {
    kind: 'literal';
    value: boolean;
};
declare type StringLiteralDefault = {
    kind: 'literal';
    value: string;
};
declare type DBGeneratedDefault = {
    kind: 'dbgenerated';
    value: string;
};
declare type AutoIncrementDefault = {
    kind: 'autoincrement';
};
declare type NowDefault = {
    kind: 'now';
};
declare type UuidDefault = {
    kind: 'uuid';
};
declare type CuidDefault = {
    kind: 'cuid';
};
export declare type ScalarDBFieldDefault<Scalar extends keyof ScalarPrismaTypes = keyof ScalarPrismaTypes, Mode extends 'required' | 'many' | 'optional' = 'required' | 'many' | 'optional'> = Mode extends 'many' ? never : {
    String: StringLiteralDefault | UuidDefault | CuidDefault;
    Boolean: BooleanLiteralDefault;
    Json: StringLiteralDefault;
    Float: NumberLiteralDefault;
    Int: AutoIncrementDefault | NumberLiteralDefault;
    BigInt: AutoIncrementDefault | BigIntLiteralDefault;
    DateTime: NowDefault | StringLiteralDefault;
    Decimal: StringLiteralDefault;
}[Scalar] | DBGeneratedDefault;
export declare type ScalarDBField<Scalar extends keyof ScalarPrismaTypes, Mode extends 'required' | 'many' | 'optional'> = {
    kind: 'scalar';
    scalar: Scalar;
    mode: Mode;
    /**
     * The native database type that the field should use. See https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model-field-scalar-types for what the possible native types should be
     * The native type should not include @datasourcename. so to specify the uuid type, the correct value for nativeType would be `Uuid`
     */
    nativeType?: string;
    default?: ScalarDBFieldDefault<Scalar, Mode>;
    index?: 'unique' | 'index';
    map?: string;
    updatedAt?: Scalar extends 'DateTime' ? boolean : undefined;
};
export declare const orderDirectionEnum: graphql.EnumType<Record<"asc" | "desc", graphql.EnumValue<"asc" | "desc">>>;
export declare const QueryMode: graphql.EnumType<Record<"default" | "insensitive", graphql.EnumValue<"default" | "insensitive">>>;
export declare type RelationDBField<Mode extends 'many' | 'one'> = {
    kind: 'relation';
    list: string;
    field?: string;
    mode: Mode;
    foreignKey?: {
        one: true | {
            map: string;
        };
        many: undefined;
    }[Mode];
    relationName?: {
        one: undefined;
        many: string;
    }[Mode];
};
export declare type EnumDBField<Value extends string, Mode extends 'required' | 'many' | 'optional'> = {
    kind: 'enum';
    name: string;
    values: readonly Value[];
    mode: Mode;
    default?: {
        kind: 'literal';
        value: Value;
    };
    index?: 'unique' | 'index';
    map?: string;
};
export declare type NoDBField = {
    kind: 'none';
};
export declare type ScalarishDBField = ScalarDBField<keyof ScalarPrismaTypes, 'required' | 'many' | 'optional'> | EnumDBField<string, 'required' | 'many' | 'optional'>;
export declare type RealDBField = ScalarishDBField | RelationDBField<'many' | 'one'>;
export declare type MultiDBField<Fields extends Record<string, ScalarishDBField>> = {
    kind: 'multi';
    fields: Fields;
};
export declare type DBField = RealDBField | NoDBField | MultiDBField<Record<string, ScalarishDBField>>;
declare type DBFieldToInputValue<TDBField extends DBField> = TDBField extends ScalarDBField<infer Scalar, infer Mode> ? {
    optional: ScalarPrismaTypes[Scalar] | null | undefined;
    required: ScalarPrismaTypes[Scalar] | undefined;
    many: readonly ScalarPrismaTypes[Scalar][] | undefined;
}[Mode] : TDBField extends RelationDBField<'many' | 'one'> ? {
    connect?: {};
    disconnect?: boolean;
} | undefined : TDBField extends EnumDBField<infer Value, infer Mode> ? {
    optional: Value | null | undefined;
    required: Value | undefined;
    many: readonly Value[] | undefined;
}[Mode] : TDBField extends NoDBField ? undefined : TDBField extends MultiDBField<infer Fields> ? {
    [Key in keyof Fields]: DBFieldToInputValue<Fields[Key]>;
} : never;
declare type DBFieldUniqueWhere<TDBField extends DBField> = TDBField extends ScalarDBField<infer Scalar, 'optional' | 'required'> ? Scalar extends 'String' | 'Int' ? {
    String: string;
    Int: number;
}[Scalar] : any : any;
declare type DBFieldToOutputValue<TDBField extends DBField> = TDBField extends ScalarDBField<infer Scalar, infer Mode> ? {
    optional: ScalarPrismaTypes[Scalar] | null;
    required: ScalarPrismaTypes[Scalar];
    many: readonly ScalarPrismaTypes[Scalar][];
}[Mode] : TDBField extends RelationDBField<infer Mode> ? {
    one: () => Promise<BaseItem>;
    many: {
        findMany(args: FindManyArgsValue): Promise<BaseItem[]>;
        count(args: {
            where: FindManyArgsValue['where'];
        }): Promise<number>;
    };
}[Mode] : TDBField extends EnumDBField<infer Value, infer Mode> ? {
    optional: Value | null;
    required: Value;
    many: readonly Value[];
}[Mode] : TDBField extends NoDBField ? undefined : TDBField extends MultiDBField<infer Fields> ? {
    [Key in keyof Fields]: DBFieldToOutputValue<Fields[Key]>;
} : never;
export declare type OrderByFieldInputArg<Val, TArg extends graphql.Arg<graphql.NullableInputType>> = {
    arg: TArg;
} & ResolveFunc<(value: Exclude<graphql.InferValueFromArg<TArg>, null | undefined>, context: KeystoneContext) => MaybePromise<Val>>;
declare type FieldInputResolver<Input, Output, RelationshipInputResolver> = (value: Input, context: KeystoneContext, relationshipInputResolver: RelationshipInputResolver) => MaybePromise<Output>;
declare type DBFieldFiltersInner<TDBField extends DBField> = Record<string, any>;
declare type DBFieldFilters<TDBField extends DBField> = ({
    AND?: DBFieldFiltersInner<TDBField>;
    OR?: DBFieldFiltersInner<TDBField>;
    NOT?: DBFieldFiltersInner<TDBField>;
} & DBFieldFiltersInner<TDBField>) | null;
export declare type WhereFieldInputArg<TDBField extends DBField, TArg extends graphql.Arg<graphql.InputType, any>> = {
    arg: TArg;
} & ResolveFunc<FieldInputResolver<Exclude<graphql.InferValueFromArg<TArg>, undefined>, DBFieldFilters<TDBField>, any>>;
export declare type UpdateFieldInputArg<TDBField extends DBField, TArg extends graphql.Arg<graphql.InputType, any>> = {
    arg: TArg;
} & ResolveFunc<FieldInputResolver<graphql.InferValueFromArg<TArg>, DBFieldToInputValue<TDBField>, any>>;
declare type CreateFieldInputResolver<Input, TDBField extends DBField> = FieldInputResolver<Input, DBFieldToInputValue<TDBField>, any>;
export declare type CreateFieldInputArg<TDBField extends DBField, TArg extends graphql.Arg<graphql.InputType, any> | undefined> = {
    arg: TArg;
} & (TArg extends graphql.Arg<graphql.InputType, any> ? graphql.InferValueFromArg<TArg> extends DBFieldToInputValue<TDBField> ? {
    resolve?: CreateFieldInputResolver<graphql.InferValueFromArg<TArg>, TDBField>;
} : {
    resolve: CreateFieldInputResolver<graphql.InferValueFromArg<TArg>, TDBField>;
} : {
    resolve: CreateFieldInputResolver<undefined, TDBField>;
});
declare type UnwrapMaybePromise<T> = T extends Promise<infer Resolved> ? Resolved : T;
declare type ResolveFunc<Func extends (firstArg: any, ...args: any[]) => any> = Parameters<Func>[0] extends UnwrapMaybePromise<ReturnType<Func>> ? {
    resolve?: Func;
} : {
    resolve: Func;
};
export declare type UniqueWhereFieldInputArg<Val, TArg extends graphql.Arg<graphql.InputType>> = {
    arg: TArg;
} & ResolveFunc<(value: Exclude<graphql.InferValueFromArg<TArg>, undefined | null>, context: KeystoneContext) => MaybePromise<Val>>;
declare type FieldTypeOutputField<TDBField extends DBField> = graphql.Field<{
    value: DBFieldToOutputValue<TDBField>;
    item: BaseItem;
}, any, graphql.OutputType, 'value'>;
export declare type OrderDirection = 'asc' | 'desc';
declare type DBFieldToOrderByValue<TDBField extends DBField> = TDBField extends ScalarishDBField ? OrderDirection | undefined : TDBField extends MultiDBField<infer Fields> ? {
    [Key in keyof Fields]: DBFieldToOrderByValue<Fields[Key]>;
} : undefined;
export declare type FieldTypeWithoutDBField<TDBField extends DBField = DBField, CreateArg extends graphql.Arg<graphql.InputType> | undefined = graphql.Arg<graphql.InputType> | undefined, UpdateArg extends graphql.Arg<graphql.InputType> = graphql.Arg<graphql.InputType>, UniqueWhereArg extends graphql.Arg<graphql.NullableInputType, false> = graphql.Arg<graphql.NullableInputType, false>, OrderByArg extends graphql.Arg<graphql.NullableInputType, false> = graphql.Arg<graphql.NullableInputType, false>, FilterArg extends graphql.Arg<graphql.NullableInputType, false> = graphql.Arg<graphql.NullableInputType, false>, ListTypeInfo extends BaseListTypeInfo = BaseListTypeInfo> = {
    input?: {
        uniqueWhere?: UniqueWhereFieldInputArg<DBFieldUniqueWhere<TDBField>, UniqueWhereArg>;
        where?: WhereFieldInputArg<TDBField, FilterArg>;
        create?: CreateFieldInputArg<TDBField, CreateArg>;
        update?: UpdateFieldInputArg<TDBField, UpdateArg>;
        orderBy?: OrderByFieldInputArg<DBFieldToOrderByValue<TDBField>, OrderByArg>;
    };
    output: FieldTypeOutputField<TDBField>;
    views: string;
    extraOutputFields?: Record<string, FieldTypeOutputField<TDBField>>;
    getAdminMeta?: (adminMeta: AdminMetaRootVal) => JSONValue;
    unreferencedConcreteInterfaceImplementations?: readonly graphql.ObjectType<any>[];
} & CommonFieldConfig<ListTypeInfo>;
declare type AnyInputObj = graphql.InputObjectType<Record<string, graphql.Arg<graphql.InputType, any>>>;
export declare type GraphQLTypesForList = {
    update: AnyInputObj;
    create: AnyInputObj;
    uniqueWhere: AnyInputObj;
    where: AnyInputObj;
    orderBy: AnyInputObj;
    output: graphql.ObjectType<BaseItem>;
    findManyArgs: FindManyArgs;
    relateTo: {
        many: {
            where: graphql.InputObjectType<{
                every: graphql.Arg<AnyInputObj>;
                some: graphql.Arg<AnyInputObj>;
                none: graphql.Arg<AnyInputObj>;
            }>;
            create?: graphql.InputObjectType<{
                connect: graphql.Arg<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['uniqueWhere']>>>;
                create?: graphql.Arg<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['create']>>>;
            }>;
            update?: graphql.InputObjectType<{
                disconnect: graphql.Arg<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['uniqueWhere']>>>;
                set: graphql.Arg<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['uniqueWhere']>>>;
                connect: graphql.Arg<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['uniqueWhere']>>>;
                create?: graphql.Arg<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['create']>>>;
            }>;
        };
        one: {
            create?: graphql.InputObjectType<{
                create?: graphql.Arg<GraphQLTypesForList['create']>;
                connect: graphql.Arg<GraphQLTypesForList['uniqueWhere']>;
            }>;
            update?: graphql.InputObjectType<{
                create?: graphql.Arg<GraphQLTypesForList['create']>;
                connect: graphql.Arg<GraphQLTypesForList['uniqueWhere']>;
                disconnect: graphql.Arg<typeof graphql.Boolean>;
            }>;
        };
    };
};
export declare type FindManyArgs = {
    where: graphql.Arg<graphql.NonNullType<GraphQLTypesForList['where']>, true>;
    orderBy: graphql.Arg<graphql.NonNullType<graphql.ListType<graphql.NonNullType<GraphQLTypesForList['orderBy']>>>, true>;
    take: graphql.Arg<typeof graphql.Int>;
    skip: graphql.Arg<graphql.NonNullType<typeof graphql.Int>, true>;
};
export declare type FindManyArgsValue = graphql.InferValueFromArgs<FindManyArgs>;
export declare function fieldType<TDBField extends DBField, ListTypeInfo extends BaseListTypeInfo>(dbField: TDBField): <CreateArg extends graphql.Arg<graphql.InputType, boolean> | undefined, UpdateArg extends graphql.Arg<graphql.InputType, boolean>, UniqueWhereArg extends graphql.Arg<graphql.NullableInputType, false>, OrderByArg extends graphql.Arg<graphql.NullableInputType, false>, FilterArg extends graphql.Arg<graphql.NullableInputType, false>>(graphQLInfo: FieldTypeWithoutDBField<TDBField, CreateArg, UpdateArg, UniqueWhereArg, OrderByArg, FilterArg, BaseListTypeInfo>) => NextFieldType<TDBField, CreateArg, UpdateArg, UniqueWhereArg, OrderByArg, FilterArg, ListTypeInfo>;
